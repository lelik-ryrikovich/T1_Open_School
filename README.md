## Задание 1  

0. Во всех таблицах и МС первичные ключи типа `Long`.

1. Использовать миграции **liquibase** или **flyway**

2. **Spring Boot 3**

3. **Java 21**

4. Можно использовать **postgreSQL**, можно использовать **in-memory DB** с готовым набором данных в проекте

5. Способ генерации данных на ваше усмотрение

---

## Сервис 1 — `Client Processing`

### Сущность `User`
- `id`
- `login`
- `password`
- `email`

### Сущность `Client`
- `id`
- `clientId`  
  Формат `clientId`: `XXFFNNNNNNNN`, где  
  - `XX` — номер региона  
  - `FF` — номер подразделения банка  
  - `N` — порядковый  
  **Например:** `770100000001`, `770200000023`
- `userId`
- `firstName`
- `middleName`
- `lastName`
- `dateOfBirth`
- `documentType` (`PASSPORT`, `INT_PASSPORT`, `BIRTH_CERT`)
- `documentId`
- `documentPrefix`
- `documentSuffix`

### Сущность `Product`
- `id`
- `name`
- `key` (`DC`, `CC`, `AC`, `IPO`, `PC`, `PENS`, `NS`, `INS`, `BS`)
- `createDate`
- `productId` (`key + id`)

### Сущность `ClientProduct`
- `id`
- `clientId`
- `productId`
- `openDate`
- `closeDate`
- `status` (`ACTIVE`, `CLOSED`, `BLOCKED`, `ARRESTED`)

---

## Сервис 2 — `Account Processing`  
(Обслуживание `DC`, `CC`, `NS`, `PENS`)

### Сущность `Account`
- `id`
- `clientId`
- `productId`
- `balance`
- `interestRate`
- `isRecalc` (признак, является ли баланс пересчитываемым автоматически)
- `cardExist`
- `status`

### Сущность `Card`
- `id`
- `accountId`
- `cardId`
- `paymentSystem`
- `status`

### Сущность `Payment`
- `id`
- `accountId`
- `paymentDate`
- `amount`
- `isCredit`
- `payedAt`
- `type`

### Сущность `Transaction`
- `id`
- `accountId`
- `cardId`
- `type`
- `amount`
- `status` (`ALLOWED`, `PROCESSING`, `COMPLETE`, `BLOCKED`, `CANCELLED`)
- `timestamp`

---

## Сервис 3 — `Credit Processing`  
(Обслуживание `IPO`, `PC`, `AC`)

### Сущность `ProductRegistry`
- `id`
- `clientId`
- `accountId`
- `productId`
- `interestRate`
- `openDate`

### Сущность `PaymentRegistry`
- `id`
- `productRegistryId`
- `paymendDate`
- `amount`
- `interestRateAmount`
- `debtAmount`
- `expired` (признак)
- `paymentExpirationDate`

---

## Задание 2

### МС-1

1. Регистрация нового клиента (POST-запрос)  
   a. Проверка на черные списки  
   b. Регистрация (создание Client)  
   c. Создание User (ответ на запрос)

2. Управление продуктами (POST-запрос) (CRUD)

3. Управление продуктами клиентского портфеля (CRUD)  
   a. DC, CC, NS, PENS  
   i. Отправка сообщения в топик `client_products`  
   b. IPO, PC, AC  
   i. Отправка сообщения в топик `client_credit_products`

4. Принимает запрос на создание карты к определенному счету  
   a. Отправляет запрос с необходимой информацией в топик `client_cards`

---

### МС-2

1. Слушает топик `client_products`  
   a. При получении сообщения создает продукт

2. Слушает топик `client_transactions`

3. Слушает топик `client_cards`  
   a. При получении сообщения создает карту, если счет не заблокирован

---

### МС-3

- Сущности `ProductRegistry` добавить атрибут `monthCount`.

1. Слушает топик `client_credit_products`  
   a. Условная проверка `clientId`  
   i. Обращение к МС-1, GET-запрос за ФИО и номером документа  
   ii. «Принятие решения»:

2. Если есть существующие кредитные продукты (A, B …), и новый желаемый продукт в сумме (A + B + C) выходит за лимит N, устанавливаемый в конфиге, то отказать.

3. Если есть существующие кредитные продукты И новый продукт в суммарной задолженности по продуктам НЕ выходит за лимит И по текущим были просрочки, то отказать.

4. Если просрочек в прошлом не было и запрашиваемая сумма укладывается в лимит N – одобрить.  
   iii. Отказ или переход к открытию продукта  

b. Открытие продукта  

c. Создание графика ежемесячных платежей на основе ставки, количества месяцев:  

### Формула
A = S × [i × (1 + i)^n] / [(1 + i)^n - 1]


Где:  
- `A` — размер аннуитетного взноса  
- `S` — сумма кредита  
- `i` — месячная процентная ставка (годовая ставка / 12)  
- `n` — количество периодов (месяцев)

#### Конкретный пример расчета

Займ 1,5 млн рублей на 5 лет под 22% годовых:

- Месячная ставка: 22% / 12 = 1,833%
- Количество выплат: 5 × 12 = 60

1 500 000 × [0,01833 × (1,01833)^60] / [(1,01833)^60 - 1]

Результат:
- Платеж: **42 287 рублей**
- Общая сумма выплат: **2 537 220 рублей**
- Переплата: **1 037 220 рублей (69%)**

При аннуитетной схеме каждый платёж состоит из:
- Проценты за пользование кредитом
- Погашение основного долга

Формулы:
Проценты = Остаток долга × r
Основной долг = P − Проценты
Новый остаток = Старый остаток − Основной долг


---

## Задание 3 — МС-2

1. Слушает топик `client_products`  
   a. При получении сообщения создает продукт

2. Слушает топик `client_transactions`  
   a. Ключ сообщения – UUID  
   b. По типу транзакции начисляет или списывает сумму транзакции с баланса счета  
   c. Если счет кредитный (`isRecalc = true`), то создать график платежей Payment  
   d. Если сервис получает больше N транзакций по одной карте (`cardId`) в период времени T, то транзакции следует заморозить, счет заблокировать  
   e. Если тип транзакции – начисление, счет кредитный, наступил день платежа и хватает средств  
      - списать сумму  
      - если средств недостаточно — платежу установить `expired`

3. Слушает топик `client_payments`  
   a. Ключ сообщения – UUID  
   b. Если сумма платежа равна задолженности — пересчитать баланс, создать Payment, обновить записи

---

## Задание 4

1. Разработать annotation based аспект `@LogDatasourceError`:<br>
  a. При возникновении исключения отправляет в топик service_logs
сообщение:
    - В качестве ключа название микросервиса
    - В заголовок передать пару String type, String value. В качестве
значения использовать `ERROR`, `WARNING`, `INFO`
    - В сообщении (json-формат) передать: timestamp, сигнатуру
метода, стектрейс исключения, текст исключения, входные
параметры метода, если таковые имеются<br>
  b. Если топик недоступен для записи или отправка не получилась, то
аналогичное сообщение записать в таблицу БД `error_log`<br>
  c. Вывести информацию об ошибке в лог консоли
2. Разработать аспект `@HttpOutcomeRequestLog` (AfterReturnig) для методов,
реализующих отправку http-запросов.<br>
  a. В качестве ключа - название микросервиса<br>
  b. В заголовке сообщения `type = INFO`<br>
  c. В сообщении timestamp, сигнатура метода, URI запроса, параметры,
тело<br>
3. Разработать Before-аспект `@HttpIncomeRequestLog` с аналогичной
информацией из п.2

---

## Задание 5  

1. Разработать аспект `@Metric`:
- Измеряет время работы метода
- Если время работы метода выше лимита, установленного в конфиге:
- Отправить сообщение в топик Кафки `service_logs` с информацией о сигнатуре метода, тип - WARNING, временем работы, входными параметрами, если таковые имеются
- Лимит выполнения устанавливается в application.yml

2. Разработать аспект `@Cached`
- Кэширует записи из БД
- Перед выполнением запроса в БД кэш должен проверяться на наличие нужной записи
- Если таковой нет - сделать запрос
- В качестве ключа - primary key, если хранилище индивидуально под сущность, или hashCode объекта, если кэш общий
- Время хранения записи в кэше задать в `application.yml`
- По истечению времени запись должна удаляться из кэша

---

## Задание 6  

0. Новый проект :)
1. Разработанные аспекты перенести в стартер
2. Предусмотреть настроечные параметры в `application.yml`
3. Обеспечить работоспособность интеграций с Kafka и БД.

---

## Задание 7  

1. Реализовать аутентификацию через JWT-токен между сервисами для HTTP-запросов
2. Для операций, направленных на управление продуктами из перечня банковских продуктов, которые может открыть клиент, реализовать ролевую модель. Создание нового продукта может делать пользователь с ролью `MASTER`, удаление - `MASTER`, `GRAND_EMPLOYEE`, редактирование `MASTER`, `GRAND_EMPLOYEE`
3. Со стороны клиентского сервиса (МС-1) при создании нового клиента выдавать роль `CURRENT_CLIENT`
- Если по уже существующему клиенту произошла блокировка (внезапно), то роль менять на `BLOCKED_CLIENT` и при попытке обратиться к сервису со стороны клиента возвращаться ошибку 403.

---

## Задание 8  

1. Покрыть Unit-тестами код, содержащий бизнес-логику в микросервисах
2. Покрыть интеграционными тестами код HTTP-запросов
3. Разработать бизнес-метрики `prometheus`, вычисляющие количество открытых продуктов в системе (ДК, КК, и пр)
